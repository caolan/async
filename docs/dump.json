[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/apply.js",
    "memberof": null,
    "longname": "lib/apply.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import rest from 'lodash/rest';\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nexport default rest(function(fn, args) {\n    return rest(function(callArgs) {\n        return fn.apply(null, args.concat(callArgs));\n    });\n});\n"
  },
  {
    "__docId__": 1,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/applyEach.js",
    "memberof": null,
    "longname": "lib/applyEach.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import applyEach from './internal/applyEach';\nimport map from './map';\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, then it will return a function which lets you pass in the\n * arguments as if it were a single function call.\n *\n * @name applyEach\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Array|Object} fns - A collection of asynchronous functions to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nexport default applyEach(map);\n"
  },
  {
    "__docId__": 2,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/applyEachSeries.js",
    "memberof": null,
    "longname": "lib/applyEachSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import applyEach from './internal/applyEach';\nimport mapSeries from './mapSeries';\n\n/**\n * The same as `applyEach` but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf async\n * @see async.applyEach\n * @category Control Flow\n * @param {Array|Object} fns - A collection of asynchronous functions to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nexport default applyEach(mapSeries);\n"
  },
  {
    "__docId__": 3,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/asyncify.js",
    "memberof": null,
    "longname": "lib/asyncify.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import isObject from 'lodash/isObject';\nimport initialParams from './internal/initialParams';\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2016 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf async\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function to convert to an\n * asynchronous function.\n * @returns {Function} An asynchronous wrapper of the `func`. To be invoked with\n * (callback).\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es6 example\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nexport default function asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function(value) {\n                callback(null, value);\n            })['catch'](function(err) {\n                callback(err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n"
  },
  {
    "__docId__": 4,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "asyncify",
    "memberof": "lib/asyncify.js",
    "longname": "lib/asyncify.js~asyncify",
    "access": null,
    "export": true,
    "importPath": "async/lib/asyncify.js",
    "importStyle": "asyncify",
    "description": "Take a sync function and make it async, passing its return value to a\ncallback. This is useful for plugging sync functions into a waterfall,\nseries, or other async functions. Any arguments passed to the generated\nfunction will be passed to the wrapped function (except for the final\ncallback argument). Errors thrown will be passed to the callback.\n\nIf the function passed to `asyncify` returns a Promise, that promises's\nresolved/rejected state will be used to call the callback, rather than simply\nthe synchronous return value.\n\nThis also means you can asyncify ES2016 `async` functions.",
    "examples": [
      "\n// passing a regular synchronous function\nasync.waterfall([\n    async.apply(fs.readFile, filename, \"utf8\"),\n    async.asyncify(JSON.parse),\n    function (data, next) {\n        // data is the result of parsing the text.\n        // If there was a parsing error, it would have been caught.\n    }\n], callback);\n\n// passing a function returning a promise\nasync.waterfall([\n    async.apply(fs.readFile, filename, \"utf8\"),\n    async.asyncify(function (contents) {\n        return db.model.create(contents);\n    }),\n    function (model, next) {\n        // `model` is the instantiated model object.\n        // If there was an error, this function would be skipped.\n    }\n], callback);\n\n// es6 example\nvar q = async.queue(async.asyncify(async function(file) {\n    var intermediateStep = await processFile(file);\n    return await somePromise(intermediateStep)\n}));\n\nq.push(files);"
    ],
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "asyncify"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@alias",
        "tagValue": "wrapSync"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} An asynchronous wrapper of the `func`. To be invoked with\n(callback)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "The synchronous function to convert to an\nasynchronous function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "An asynchronous wrapper of the `func`. To be invoked with\n(callback)."
    },
    "generator": false
  },
  {
    "__docId__": 5,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/auto.js",
    "memberof": null,
    "longname": "lib/auto.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import arrayEach from 'lodash/_arrayEach';\nimport forOwn from 'lodash/forOwn';\nimport indexOf from 'lodash/_baseIndexOf';\nimport isArray from 'lodash/isArray';\nimport okeys from 'lodash/keys';\nimport noop from 'lodash/noop';\nimport once from './internal/once';\nimport rest from 'lodash/rest';\n\nimport onlyOnce from './internal/onlyOnce';\n\n/**\n * Determines the best order for running the functions in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the functions pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * Functions also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the function itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nexport default function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys = okeys(tasks);\n    var numTasks = keys.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = {};\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    forOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(rest(function(err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                forOwn(results, function(val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = [];\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = task[task.length - 1];\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (!(--uncheckedDependencies[dependent])) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        forOwn(tasks, function (task, key) {\n            if (isArray(task) && indexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n}\n"
  },
  {
    "__docId__": 6,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "auto",
    "memberof": "lib/auto.js",
    "longname": "lib/auto.js~auto",
    "access": null,
    "export": true,
    "importPath": "async/lib/auto.js",
    "importStyle": "auto",
    "description": "Determines the best order for running the functions in `tasks`, based on\ntheir requirements. Each function can optionally depend on other functions\nbeing completed first, and each function is run as soon as its requirements\nare satisfied.\n\nIf any of the functions pass an error to their callback, the `auto` sequence\nwill stop. Further tasks will not execute (so any other functions depending\non it will not run), and the main `callback` is immediately called with the\nerror.\n\nFunctions also receive an object containing the results of functions which\nhave completed so far as the first argument, if they have dependencies. If a\ntask function has no dependencies, it will only be passed a callback.",
    "examples": [
      "\nasync.auto({\n    // this function will just be passed a callback\n    readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n    showData: ['readData', function(results, cb) {\n        // results.readData is the file's contents\n        // ...\n    }]\n}, callback);\n\nasync.auto({\n    get_data: function(callback) {\n        console.log('in get_data');\n        // async code to get some data\n        callback(null, 'data', 'converted to array');\n    },\n    make_folder: function(callback) {\n        console.log('in make_folder');\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n        callback(null, 'folder');\n    },\n    write_file: ['get_data', 'make_folder', function(results, callback) {\n        console.log('in write_file', JSON.stringify(results));\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, 'filename');\n    }],\n    email_link: ['write_file', function(results, callback) {\n        console.log('in email_link', JSON.stringify(results));\n        // once the file is written let's email a link to it...\n        // results.write_file contains the filename returned by write_file.\n        callback(null, {'file':results.write_file, 'email':'user@example.com'});\n    }]\n}, function(err, results) {\n    console.log('err = ', err);\n    console.log('results = ', results);\n});"
    ],
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "auto"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "undefined"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "An object. Each of its properties is either a\nfunction or an array of requirements, with the function itself the last item\nin the array. The object's key of a property serves as the name of the task\ndefined by that property, i.e. can be used when specifying requirements for\nother tasks. The function receives one or two arguments:\n* a `results` object, containing the results of the previously executed\n  functions, only passed if the task has any dependencies,\n* a `callback(err, result)` function, which must be called when finished,\n  passing an `error` (which can be `null`) and the result of the function's\n  execution."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Infinity",
        "defaultRaw": "Infinity",
        "name": "concurrency",
        "description": "An optional `integer` for\ndetermining the maximum number of tasks that can be run in parallel. By\ndefault, as many as possible."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "An optional callback which is called when all\nthe tasks have been completed. It receives the `err` argument if any `tasks`\npass an error to their callback. Results are always returned; however, if an\nerror occurs, no further `tasks` will be performed, and the results object\nwill only contain partial results. Invoked with (err, results)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "undefined"
    },
    "generator": false
  },
  {
    "__docId__": 7,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/autoInject.js",
    "memberof": null,
    "longname": "lib/autoInject.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import auto from './auto';\nimport forOwn from 'lodash/forOwn';\nimport arrayMap from 'lodash/_arrayMap';\nimport clone from 'lodash/_copyArray';\nimport isArray from 'lodash/isArray';\nimport trim from 'lodash/trim';\n\nvar argsRegex = /^(function[^\\(]*)?\\(?\\s*([^\\)=]*)/m;\n\nfunction parseParams(func) {\n    return trim(func.toString().match(argsRegex)[2]).split(/\\s*\\,\\s*/);\n}\n\n/**\n * A dependency-injected version of the {@link async.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to {@link async.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf async\n * @see async.auto\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is a function of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. The remaining parameters are task names\n * whose results you are interested in. This callback will only be called when\n * all tasks have finished or an error has occurred, and so do not specify\n * dependencies in the same way as `tasks` do. If an error occurs, no further\n * `tasks` will be performed, and `results` will only be valid for those tasks\n * which managed to complete. Invoked with (err, [results...]).\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, email_link) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.  The final\n * // results callback can be provided as an array in the same way.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, ['email_link', function(err, email_link) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', email_link);\n * }]);\n */\nexport default function autoInject(tasks, callback) {\n    var newTasks = {};\n\n    forOwn(tasks, function (taskFn, key) {\n        var params;\n\n        if (isArray(taskFn)) {\n            params = clone(taskFn);\n            taskFn = params.pop();\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (taskFn.length === 0) {\n            throw new Error(\"autoInject task functions require explicit parameters.\");\n        } else if (taskFn.length === 1) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            taskFn.apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n"
  },
  {
    "__docId__": 8,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "argsRegex",
    "memberof": "lib/autoInject.js",
    "longname": "lib/autoInject.js~argsRegex",
    "access": null,
    "export": false,
    "importPath": "async/lib/autoInject.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "object"
      ]
    }
  },
  {
    "__docId__": 9,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseParams",
    "memberof": "lib/autoInject.js",
    "longname": "lib/autoInject.js~parseParams",
    "access": null,
    "export": false,
    "importPath": "async/lib/autoInject.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "func",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 10,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "autoInject",
    "memberof": "lib/autoInject.js",
    "longname": "lib/autoInject.js~autoInject",
    "access": null,
    "export": true,
    "importPath": "async/lib/autoInject.js",
    "importStyle": "autoInject",
    "description": "A dependency-injected version of the {@link async.auto} function. Dependent\ntasks are specified as parameters to the function, after the usual callback\nparameter, with the parameter names matching the names of the tasks it\ndepends on. This can provide even more readable task graphs which can be\neasier to maintain.\n\nIf a final callback is specified, the task results are similarly injected,\nspecified as named parameters after the initial error parameter.\n\nThe autoInject function is purely syntactic sugar and its semantics are\notherwise equivalent to {@link async.auto}.",
    "examples": [
      "\n//  The example from `auto` can be rewritten as follows:\nasync.autoInject({\n    get_data: function(callback) {\n        // async code to get some data\n        callback(null, 'data', 'converted to array');\n    },\n    make_folder: function(callback) {\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n        callback(null, 'folder');\n    },\n    write_file: function(get_data, make_folder, callback) {\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, 'filename');\n    },\n    email_link: function(write_file, callback) {\n        // once the file is written let's email a link to it...\n        // write_file contains the filename returned by write_file.\n        callback(null, {'file':write_file, 'email':'user@example.com'});\n    }\n}, function(err, email_link) {\n    console.log('err = ', err);\n    console.log('email_link = ', email_link);\n});\n\n// If you are using a JS minifier that mangles parameter names, `autoInject`\n// will not work with plain functions, since the parameter names will be\n// collapsed to a single letter identifier.  To work around this, you can\n// explicitly specify the names of the parameters your task function needs\n// in an array, similar to Angular.js dependency injection.  The final\n// results callback can be provided as an array in the same way.\n\n// This still has an advantage over plain `auto`, since the results a task\n// depends on are still spread into arguments.\nasync.autoInject({\n    //...\n    write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n        callback(null, 'filename');\n    }],\n    email_link: ['write_file', function(write_file, callback) {\n        callback(null, {'file':write_file, 'email':'user@example.com'});\n    }]\n    //...\n}, ['email_link', function(err, email_link) {\n    console.log('err = ', err);\n    console.log('email_link = ', email_link);\n}]);"
    ],
    "see": [
      "async.auto"
    ],
    "lineNumber": 100,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "autoInject"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "An object, each of whose properties is a function of\nthe form 'func([dependencies...], callback). The object's key of a property\nserves as the name of the task defined by that property, i.e. can be used\nwhen specifying requirements for other tasks.\n* The `callback` parameter is a `callback(err, result)` which must be called\n  when finished, passing an `error` (which can be `null`) and the result of\n  the function's execution. The remaining parameters name other tasks on\n  which the task is dependent, and the results from those tasks are the\n  arguments of those parameters."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "An optional callback which is called when all\nthe tasks have been completed. It receives the `err` argument if any `tasks`\npass an error to their callback. The remaining parameters are task names\nwhose results you are interested in. This callback will only be called when\nall tasks have finished or an error has occurred, and so do not specify\ndependencies in the same way as `tasks` do. If an error occurs, no further\n`tasks` will be performed, and `results` will only be valid for those tasks\nwhich managed to complete. Invoked with (err, [results...])."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 11,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/cargo.js",
    "memberof": null,
    "longname": "lib/cargo.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import queue from './internal/queue';\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as {@link async.queue}.\n * @typedef {Object} CargoObject\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [queue](#queue) passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf async\n * @see async.queue\n * @category Control Flow\n * @param {Function} worker - An asynchronous function for processing an array\n * of queued tasks, which must call its `callback(err)` argument when finished,\n * with an optional `err` argument. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nexport default function cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n"
  },
  {
    "__docId__": 12,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "CargoObject",
    "memberof": "lib/cargo.js",
    "longname": "lib/cargo.js~CargoObject",
    "access": null,
    "description": "A cargo of tasks for the worker function to complete. Cargo inherits all of\nthe same methods and event callbacks as {@link async.queue}.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "A function returning the number of items\nwaiting to be processed. Invoke like `cargo.length()`."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "payload",
        "description": "An `integer` for determining how many tasks\nshould be process per round. This property can be changed after a `cargo` is\ncreated to alter the payload on-the-fly."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "push",
        "description": "Adds `task` to the `queue`. The callback is\ncalled once the `worker` has finished processing the task. Instead of a\nsingle task, an array of `tasks` can be submitted. The respective callback is\nused for every task in the list. Invoke like `cargo.push(task, [callback])`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "saturated",
        "description": "A callback that is called when the\n`queue.length()` hits the concurrency and further tasks will be queued."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "empty",
        "description": "A callback that is called when the last item\nfrom the `queue` is given to a `worker`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "drain",
        "description": "A callback that is called when the last item\nfrom the `queue` has returned from the `worker`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "idle",
        "description": "a function returning false if there are items\nwaiting or being processed, or true if not. Invoke like `cargo.idle()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "pause",
        "description": "a function that pauses the processing of tasks\nuntil `resume()` is called. Invoke like `cargo.pause()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "resume",
        "description": "a function that resumes the processing of\nqueued tasks when the queue is paused. Invoke like `cargo.resume()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "kill",
        "description": "a function that removes the `drain` callback and\nempties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "CargoObject"
    }
  },
  {
    "__docId__": 13,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "cargo",
    "memberof": "lib/cargo.js",
    "longname": "lib/cargo.js~cargo",
    "access": null,
    "export": true,
    "importPath": "async/lib/cargo.js",
    "importStyle": "cargo",
    "description": "Creates a `cargo` object with the specified payload. Tasks added to the\ncargo will be processed altogether (up to the `payload` limit). If the\n`worker` is in progress, the task is queued until it becomes available. Once\nthe `worker` has completed some tasks, each callback of those tasks is\ncalled. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\nfor how `cargo` and `queue` work.\n\nWhile [queue](#queue) passes only one task to one of a group of workers\nat a time, cargo passes an array of tasks to a single worker, repeating\nwhen the worker is finished.",
    "examples": [
      "\n// create a cargo object with payload 2\nvar cargo = async.cargo(function(tasks, callback) {\n    for (var i=0; i<tasks.length; i++) {\n        console.log('hello ' + tasks[i].name);\n    }\n    callback();\n}, 2);\n\n// add some items\ncargo.push({name: 'foo'}, function(err) {\n    console.log('finished processing foo');\n});\ncargo.push({name: 'bar'}, function(err) {\n    console.log('finished processing bar');\n});\ncargo.push({name: 'baz'}, function(err) {\n    console.log('finished processing baz');\n});"
    ],
    "see": [
      "async.queue"
    ],
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "cargo"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "{CargoObject} A cargo object to manage the tasks. Callbacks can\nattached as certain properties to listen for specific events during the\nlifecycle of the cargo and inner queue."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "worker",
        "description": "An asynchronous function for processing an array\nof queued tasks, which must call its `callback(err)` argument when finished,\nwith an optional `err` argument. Invoked with `(tasks, callback)`."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Infinity",
        "defaultRaw": "Infinity",
        "name": "payload",
        "description": "An optional `integer` for determining\nhow many tasks should be processed per round; if omitted, the default is\nunlimited."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CargoObject"
      ],
      "spread": false,
      "description": "A cargo object to manage the tasks. Callbacks can\nattached as certain properties to listen for specific events during the\nlifecycle of the cargo and inner queue."
    },
    "generator": false
  },
  {
    "__docId__": 14,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/compose.js",
    "memberof": null,
    "longname": "lib/compose.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import seq from './seq';\n\nvar reverse = Array.prototype.reverse;\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {...Function} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nexport default function compose(/* functions... */) {\n    return seq.apply(null, reverse.call(arguments));\n}\n"
  },
  {
    "__docId__": 15,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "reverse",
    "memberof": "lib/compose.js",
    "longname": "lib/compose.js~reverse",
    "access": null,
    "export": false,
    "importPath": "async/lib/compose.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "compose",
    "memberof": "lib/compose.js",
    "longname": "lib/compose.js~compose",
    "access": null,
    "export": true,
    "importPath": "async/lib/compose.js",
    "importStyle": "compose",
    "description": "Creates a function which is a composition of the passed asynchronous\nfunctions. Each function consumes the return value of the function that\nfollows. Composing functions `f()`, `g()`, and `h()` would produce the result\nof `f(g(h()))`, only this version uses callbacks to obtain the return values.\n\nEach function is executed with the `this` binding of the composed function.",
    "examples": [
      "\nfunction add1(n, callback) {\n    setTimeout(function () {\n        callback(null, n + 1);\n    }, 10);\n}\n\nfunction mul3(n, callback) {\n    setTimeout(function () {\n        callback(null, n * 3);\n    }, 10);\n}\n\nvar add1mul3 = async.compose(mul3, add1);\nadd1mul3(4, function (err, result) {\n    // result now equals 15\n});"
    ],
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "compose"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} an asynchronous function that is the composed\nasynchronous `functions`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "...Function"
        ],
        "spread": true,
        "optional": false,
        "name": "functions",
        "description": "the asynchronous functions to compose"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "an asynchronous function that is the composed\nasynchronous `functions`"
    },
    "generator": false
  },
  {
    "__docId__": 17,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/concat.js",
    "memberof": null,
    "longname": "lib/concat.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import concat from './internal/concat';\nimport doParallel from './internal/doParallel';\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf async\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, results)` which must be called once\n * it has completed with an error (which can be `null`) and an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nexport default doParallel(concat);\n"
  },
  {
    "__docId__": 18,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/concatSeries.js",
    "memberof": null,
    "longname": "lib/concatSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import concat from './internal/concat';\nimport doSeries from './internal/doSeries';\n\n/**\n * The same as `concat` but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf async\n * @see async.concat\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, results)` which must be called once\n * it has completed with an error (which can be `null`) and an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nexport default doSeries(concat);\n"
  },
  {
    "__docId__": 19,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/constant.js",
    "memberof": null,
    "longname": "lib/constant.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import rest from 'lodash/rest';\nimport initialParams from './internal/initialParams';\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a `waterfall`, or for plugging values in to\n * `auto`.\n *\n * @name constant\n * @static\n * @memberOf async\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {Function} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nexport default rest(function(values) {\n    var args = [null].concat(values);\n    return initialParams(function (ignoredArgs, callback) {\n        return callback.apply(this, args);\n    });\n});\n"
  },
  {
    "__docId__": 20,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/detect.js",
    "memberof": null,
    "longname": "lib/detect.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import identity from 'lodash/identity';\n\nimport createTester from './internal/createTester';\nimport eachOf from './eachOf';\nimport findGetResult from './internal/findGetResult';\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * `detectSeries`.\n *\n * @name detect\n * @static\n * @memberOf async\n * @alias find\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, truthValue)` which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nexport default createTester(eachOf, identity, findGetResult);\n"
  },
  {
    "__docId__": 21,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/detectLimit.js",
    "memberof": null,
    "longname": "lib/detectLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import identity from 'lodash/identity';\n\nimport createTester from './internal/createTester';\nimport eachOfLimit from './eachOfLimit';\nimport findGetResult from './internal/findGetResult';\n\n/**\n * The same as `detect` but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf async\n * @see async.detect\n * @alias findLimit\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, truthValue)` which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nexport default createTester(eachOfLimit, identity, findGetResult);\n"
  },
  {
    "__docId__": 22,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/detectSeries.js",
    "memberof": null,
    "longname": "lib/detectSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import identity from 'lodash/identity';\n\nimport createTester from './internal/createTester';\nimport eachOfSeries from './eachOfSeries';\nimport findGetResult from './internal/findGetResult';\n\n/**\n * The same as `detect` but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf async\n * @see async.detect\n * @alias findSeries\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, truthValue)` which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nexport default createTester(eachOfSeries, identity, findGetResult);\n"
  },
  {
    "__docId__": 23,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/dir.js",
    "memberof": null,
    "longname": "lib/dir.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import consoleFunc from './internal/consoleFunc';\n\n/**\n * Logs the result of an `async` function to the `console` using `console.dir`\n * to display the properties of the resulting object. Only works in Node.js or\n * in browsers that support `console.dir` and `console.error` (such as FF and\n * Chrome). If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nexport default consoleFunc('dir');\n"
  },
  {
    "__docId__": 24,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/doDuring.js",
    "memberof": null,
    "longname": "lib/doDuring.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import during from './during';\n\n/**\n * The post-check version of {@link async.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of {@link async.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf async\n * @see async.during\n * @category Control Flow\n * @param {Function} fn - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n */\nexport default function doDuring(fn, test, callback) {\n    var calls = 0;\n\n    during(function(next) {\n        if (calls++ < 1) return next(null, true);\n        test.apply(this, arguments);\n    }, fn, callback);\n}\n"
  },
  {
    "__docId__": 25,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "doDuring",
    "memberof": "lib/doDuring.js",
    "longname": "lib/doDuring.js~doDuring",
    "access": null,
    "export": true,
    "importPath": "async/lib/doDuring.js",
    "importStyle": "doDuring",
    "description": "The post-check version of {@link async.during}. To reflect the difference in\nthe order of operations, the arguments `test` and `fn` are switched.\n\nAlso a version of {@link async.doWhilst} with asynchronous `test` function.",
    "see": [
      "async.during"
    ],
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "doDuring"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "A function which is called each time `test` passes.\nThe function is passed a `callback(err)`, which must be called once it has\ncompleted with an optional `err` argument. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "asynchronous truth test to perform before each\nexecution of `fn`. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after the test\nfunction has failed and repeated execution of `fn` has stopped. `callback`\nwill be passed an error and any arguments passed to the final `fn`'s\ncallback. Invoked with (err, [results]);"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 26,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/doUntil.js",
    "memberof": null,
    "longname": "lib/doUntil.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import doWhilst from './doWhilst';\n\n/**\n * Like {@link async.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf async\n * @see async.doWhilst\n * @category Control Flow\n * @param {Function} fn - A function which is called each time `test` fails.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `fn`. Invoked with the non-error callback results of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n */\nexport default function doUntil(fn, test, callback) {\n    doWhilst(fn, function() {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n"
  },
  {
    "__docId__": 27,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "doUntil",
    "memberof": "lib/doUntil.js",
    "longname": "lib/doUntil.js~doUntil",
    "access": null,
    "export": true,
    "importPath": "async/lib/doUntil.js",
    "importStyle": "doUntil",
    "description": "Like {@link async.doWhilst}, except the `test` is inverted. Note the\nargument ordering differs from `until`.",
    "see": [
      "async.doWhilst"
    ],
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "doUntil"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "A function which is called each time `test` fails.\nThe function is passed a `callback(err)`, which must be called once it has\ncompleted with an optional `err` argument. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "synchronous truth test to perform after each\nexecution of `fn`. Invoked with the non-error callback results of `fn`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after the test\nfunction has passed and repeated execution of `fn` has stopped. `callback`\nwill be passed an error and any arguments passed to the final `fn`'s\ncallback. Invoked with (err, [results]);"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 28,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/doWhilst.js",
    "memberof": null,
    "longname": "lib/doWhilst.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import whilst from './whilst';\n\n/**\n * The post-check version of {@link async.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf async\n * @see async.whilst\n * @category Control Flow\n * @param {Function} fn - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `fn`. Invoked with Invoked with the non-error callback results\n * of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n */\nexport default function doWhilst(fn, test, callback) {\n    var calls = 0;\n    whilst(function() {\n        return ++calls <= 1 || test.apply(this, arguments);\n    }, fn, callback);\n}\n"
  },
  {
    "__docId__": 29,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "doWhilst",
    "memberof": "lib/doWhilst.js",
    "longname": "lib/doWhilst.js~doWhilst",
    "access": null,
    "export": true,
    "importPath": "async/lib/doWhilst.js",
    "importStyle": "doWhilst",
    "description": "The post-check version of {@link async.whilst}. To reflect the difference in\nthe order of operations, the arguments `test` and `fn` are switched.\n\n`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.",
    "see": [
      "async.whilst"
    ],
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "doWhilst"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "A function which is called each time `test` passes.\nThe function is passed a `callback(err)`, which must be called once it has\ncompleted with an optional `err` argument. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "synchronous truth test to perform after each\nexecution of `fn`. Invoked with Invoked with the non-error callback results\nof `fn`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after the test\nfunction has failed and repeated execution of `fn` has stopped. `callback`\nwill be passed an error and any arguments passed to the final `fn`'s\ncallback. Invoked with (err, [results]);"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 30,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/during.js",
    "memberof": null,
    "longname": "lib/during.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import noop from 'lodash/noop';\nimport rest from 'lodash/rest';\n\n/**\n * Like {@link async.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf async\n * @see async.whilst\n * @category Control Flow\n * @param {Function} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {Function} fn - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nexport default function during(test, fn, callback) {\n    callback = callback || noop;\n\n    var next = rest(function(err, args) {\n        if (err) {\n            callback(err);\n        } else {\n            args.push(check);\n            test.apply(this, args);\n        }\n    });\n\n    var check = function(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        fn(next);\n    };\n\n    test(check);\n}\n"
  },
  {
    "__docId__": 31,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "during",
    "memberof": "lib/during.js",
    "longname": "lib/during.js~during",
    "access": null,
    "export": true,
    "importPath": "async/lib/during.js",
    "importStyle": "during",
    "description": "Like {@link async.whilst}, except the `test` is an asynchronous function that\nis passed a callback in the form of `function (err, truth)`. If error is\npassed to `test` or `fn`, the main callback is immediately called with the\nvalue of the error.",
    "examples": [
      "\nvar count = 0;\n\nasync.during(\n    function (callback) {\n        return callback(null, count < 5);\n    },\n    function (callback) {\n        count++;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n        // 5 seconds have passed\n    }\n);"
    ],
    "see": [
      "async.whilst"
    ],
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "during"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "asynchronous truth test to perform before each\nexecution of `fn`. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "A function which is called each time `test` passes.\nThe function is passed a `callback(err)`, which must be called once it has\ncompleted with an optional `err` argument. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after the test\nfunction has failed and repeated execution of `fn` has stopped. `callback`\nwill be passed an error and any arguments passed to the final `fn`'s\ncallback. Invoked with (err, [results]);"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 32,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/each.js",
    "memberof": null,
    "longname": "lib/each.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachLimit from './eachLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf async\n * @alias forEach\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item\n * in `coll`. The iteratee is passed a `callback(err)` which must be called once\n * it has completed. If no error has occurred, the `callback` should be run\n * without arguments or with an explicit `null` argument. The array index is not\n * passed to the iteratee. Invoked with (item, callback). If you need the index,\n * use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nexport default doLimit(eachLimit, Infinity);\n"
  },
  {
    "__docId__": 33,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/eachLimit.js",
    "memberof": null,
    "longname": "lib/eachLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachOfLimit from './internal/eachOfLimit';\nimport withoutIndex from './internal/withoutIndex';\n\n/**\n * The same as `each` but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf async\n * @see async.each\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Object} coll - A colleciton to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each item in `coll`. The\n * iteratee is passed a `callback(err)` which must be called once it has\n * completed. If no error has occurred, the `callback` should be run without\n * arguments or with an explicit `null` argument. The array index is not passed\n * to the iteratee. Invoked with (item, callback). If you need the index, use\n * `eachOfLimit`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nexport default function eachLimit(coll, limit, iteratee, callback) {\n    eachOfLimit(limit)(coll, withoutIndex(iteratee), callback);\n}\n"
  },
  {
    "__docId__": 34,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "eachLimit",
    "memberof": "lib/eachLimit.js",
    "longname": "lib/eachLimit.js~eachLimit",
    "access": null,
    "export": true,
    "importPath": "async/lib/eachLimit.js",
    "importStyle": "eachLimit",
    "description": "The same as `each` but runs a maximum of `limit` async operations at a time.",
    "see": [
      "async.each"
    ],
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "eachLimit"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@alias",
        "tagValue": "forEachLimit"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "coll",
        "description": "A colleciton to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "limit",
        "description": "The maximum number of async operations at a time."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function to apply to each item in `coll`. The\niteratee is passed a `callback(err)` which must be called once it has\ncompleted. If no error has occurred, the `callback` should be run without\narguments or with an explicit `null` argument. The array index is not passed\nto the iteratee. Invoked with (item, callback). If you need the index, use\n`eachOfLimit`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called when all\n`iteratee` functions have finished, or an error occurs. Invoked with (err)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 35,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/eachOf.js",
    "memberof": null,
    "longname": "lib/eachOf.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachOfLimit from './eachOfLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Like `each`, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf async\n * @alias forEachOf\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array. The iteratee is passed a `callback(err)` which must be called once it\n * has completed. If no error has occurred, the callback should be run without\n * arguments or with an explicit `null` argument. Invoked with\n * (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nexport default doLimit(eachOfLimit, Infinity);\n"
  },
  {
    "__docId__": 36,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/eachOfLimit.js",
    "memberof": null,
    "longname": "lib/eachOfLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _eachOfLimit from './internal/eachOfLimit';\n\n/**\n * The same as `eachOf` but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf async\n * @see async.eachOf\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array. The iteratee is passed a `callback(err)` which must be called once it\n * has completed. If no error has occurred, the callback should be run without\n * arguments or with an explicit `null` argument. Invoked with\n * (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nexport default function eachOfLimit(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, iteratee, callback);\n}\n"
  },
  {
    "__docId__": 37,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "eachOfLimit",
    "memberof": "lib/eachOfLimit.js",
    "longname": "lib/eachOfLimit.js~eachOfLimit",
    "access": null,
    "export": true,
    "importPath": "async/lib/eachOfLimit.js",
    "importStyle": "eachOfLimit",
    "description": "The same as `eachOf` but runs a maximum of `limit` async operations at a\ntime.",
    "see": [
      "async.eachOf"
    ],
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "eachOfLimit"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@alias",
        "tagValue": "forEachOfLimit"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "coll",
        "description": "A collection to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "limit",
        "description": "The maximum number of async operations at a time."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function to apply to each\nitem in `coll`. The `key` is the item's key, or index in the case of an\narray. The iteratee is passed a `callback(err)` which must be called once it\nhas completed. If no error has occurred, the callback should be run without\narguments or with an explicit `null` argument. Invoked with\n(item, key, callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called when all\n`iteratee` functions have finished, or an error occurs. Invoked with (err)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 38,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/eachOfSeries.js",
    "memberof": null,
    "longname": "lib/eachOfSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachOfLimit from './eachOfLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `eachOf` but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf async\n * @see async.eachOf\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`. The\n * `key` is the item's key, or index in the case of an array. The iteratee is\n * passed a `callback(err)` which must be called once it has completed. If no\n * error has occurred, the callback should be run without arguments or with an\n * explicit `null` argument. Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nexport default doLimit(eachOfLimit, 1);\n"
  },
  {
    "__docId__": 39,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/eachSeries.js",
    "memberof": null,
    "longname": "lib/eachSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachLimit from './eachLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `each` but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf async\n * @see async.each\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each\n * item in `coll`. The iteratee is passed a `callback(err)` which must be called\n * once it has completed. If no error has occurred, the `callback` should be run\n * without arguments or with an explicit `null` argument. The array index is\n * not passed to the iteratee. Invoked with (item, callback). If you need the\n * index, use `eachOfSeries`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nexport default doLimit(eachLimit, 1);\n"
  },
  {
    "__docId__": 40,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/ensureAsync.js",
    "memberof": null,
    "longname": "lib/ensureAsync.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import setImmediate from './internal/setImmediate';\nimport initialParams from './internal/initialParams';\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained.\n *\n * @name ensureAsync\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {Function} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nexport default function ensureAsync(fn) {\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n"
  },
  {
    "__docId__": 41,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "ensureAsync",
    "memberof": "lib/ensureAsync.js",
    "longname": "lib/ensureAsync.js~ensureAsync",
    "access": null,
    "export": true,
    "importPath": "async/lib/ensureAsync.js",
    "importStyle": "ensureAsync",
    "description": "Wrap an async function and ensure it calls its callback on a later tick of\nthe event loop.  If the function already calls its callback on a next tick,\nno extra deferral is added. This is useful for preventing stack overflows\n(`RangeError: Maximum call stack size exceeded`) and generally keeping\n[Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\ncontained.",
    "examples": [
      "\nfunction sometimesAsync(arg, callback) {\n    if (cache[arg]) {\n        return callback(null, cache[arg]); // this would be synchronous!!\n    } else {\n        doSomeIO(arg, callback); // this IO would be asynchronous\n    }\n}\n\n// this has a risk of stack overflows if many results are cached in a row\nasync.mapSeries(args, sometimesAsync, done);\n\n// this will defer sometimesAsync's callback if necessary,\n// preventing stack overflows\nasync.mapSeries(args, async.ensureAsync(sometimesAsync), done);"
    ],
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "ensureAsync"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} Returns a wrapped function with the exact same call\nsignature as the function passed in."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "an async function, one that expects a node-style\ncallback as its last argument."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "Returns a wrapped function with the exact same call\nsignature as the function passed in."
    },
    "generator": false
  },
  {
    "__docId__": 42,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/every.js",
    "memberof": null,
    "longname": "lib/every.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import everyLimit from './everyLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf async\n * @alias all\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the\n * collection in parallel. The iteratee is passed a `callback(err, truthValue)`\n * which must be called with a  boolean argument once it has completed. Invoked\n * with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nexport default doLimit(everyLimit, Infinity);\n"
  },
  {
    "__docId__": 43,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/everyLimit.js",
    "memberof": null,
    "longname": "lib/everyLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import createTester from './internal/createTester';\nimport eachOfLimit from './eachOfLimit';\nimport notId from './internal/notId';\n\n/**\n * The same as `every` but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf async\n * @see async.every\n * @alias allLimit\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in the\n * collection in parallel. The iteratee is passed a `callback(err, truthValue)`\n * which must be called with a  boolean argument once it has completed. Invoked\n * with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nexport default createTester(eachOfLimit, notId, notId);\n"
  },
  {
    "__docId__": 44,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/everySeries.js",
    "memberof": null,
    "longname": "lib/everySeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import everyLimit from './everyLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `every` but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf async\n * @see async.every\n * @alias allSeries\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the\n * collection in parallel. The iteratee is passed a `callback(err, truthValue)`\n * which must be called with a  boolean argument once it has completed. Invoked\n * with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nexport default doLimit(everyLimit, 1);\n"
  },
  {
    "__docId__": 45,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/filter.js",
    "memberof": null,
    "longname": "lib/filter.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import filterLimit from './filterLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf async\n * @alias select\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nexport default doLimit(filterLimit, Infinity);\n"
  },
  {
    "__docId__": 46,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/filterLimit.js",
    "memberof": null,
    "longname": "lib/filterLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import filter from './internal/filter';\nimport doParallelLimit from './internal/doParallelLimit';\n\n/**\n * The same as `filter` but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf async\n * @see async.filter\n * @alias selectLimit\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nexport default doParallelLimit(filter);\n"
  },
  {
    "__docId__": 47,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/filterSeries.js",
    "memberof": null,
    "longname": "lib/filterSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import filterLimit from './filterLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `filter` but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf async\n * @see async.filter\n * @alias selectSeries\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nexport default doLimit(filterLimit, 1);\n"
  },
  {
    "__docId__": 48,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/forever.js",
    "memberof": null,
    "longname": "lib/forever.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import noop from 'lodash/noop';\n\nimport onlyOnce from './internal/onlyOnce';\nimport ensureAsync from './ensureAsync';\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the\n * callback then `errback` is called with the error, and execution stops,\n * otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Function} fn - a function to call repeatedly. Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nexport default function forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = ensureAsync(fn);\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n"
  },
  {
    "__docId__": 49,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "forever",
    "memberof": "lib/forever.js",
    "longname": "lib/forever.js~forever",
    "access": null,
    "export": true,
    "importPath": "async/lib/forever.js",
    "importStyle": "forever",
    "description": "Calls the asynchronous function `fn` with a callback parameter that allows it\nto call itself again, in series, indefinitely.\n\nIf an error is passed to the\ncallback then `errback` is called with the error, and execution stops,\notherwise it will never be called.",
    "examples": [
      "\nasync.forever(\n    function(next) {\n        // next is suitable for passing to things that need a callback(err [, whatever]);\n        // it will result in this function being called again.\n    },\n    function(err) {\n        // if next is called with a value in its first parameter, it will appear\n        // in here as 'err', and execution will stop.\n    }\n);"
    ],
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "forever"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "a function to call repeatedly. Invoked with (next)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "errback",
        "description": "when `fn` passes an error to it's callback,\nthis function will be called, and execution stops. Invoked with (err)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 50,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/index.js",
    "memberof": null,
    "longname": "lib/index.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @namespace async\n */\nimport applyEach from './applyEach';\nimport applyEachSeries from './applyEachSeries';\nimport apply from './apply';\nimport asyncify from './asyncify';\nimport auto from './auto';\nimport autoInject from './autoInject';\nimport cargo from './cargo';\nimport compose from './compose';\nimport concat from './concat';\nimport concatSeries from './concatSeries';\nimport constant from './constant';\nimport detect from './detect';\nimport detectLimit from './detectLimit';\nimport detectSeries from './detectSeries';\nimport dir from './dir';\nimport doDuring from './doDuring';\nimport doUntil from './doUntil';\nimport doWhilst from './doWhilst';\nimport during from './during';\nimport each from './each';\nimport eachLimit from './eachLimit';\nimport eachOf from './eachOf';\nimport eachOfLimit from './eachOfLimit';\nimport eachOfSeries from './eachOfSeries';\nimport eachSeries from './eachSeries';\nimport ensureAsync from './ensureAsync';\nimport every from './every';\nimport everyLimit from './everyLimit';\nimport everySeries from './everySeries';\nimport filter from './filter';\nimport filterLimit from './filterLimit';\nimport filterSeries from './filterSeries';\nimport forever from './forever';\nimport iterator from './iterator';\nimport log from './log';\nimport map from './map';\nimport mapLimit from './mapLimit';\nimport mapSeries from './mapSeries';\nimport mapValues from './mapValues';\nimport mapValuesLimit from './mapValuesLimit';\nimport mapValuesSeries from './mapValuesSeries';\nimport memoize from './memoize';\nimport nextTick from './nextTick';\nimport parallel from './parallel';\nimport parallelLimit from './parallelLimit';\nimport priorityQueue from './priorityQueue';\nimport queue from './queue';\nimport race from './race';\nimport reduce from './reduce';\nimport reduceRight from './reduceRight';\nimport reflect from './reflect';\nimport reject from './reject';\nimport reflectAll from './reflectAll';\nimport rejectLimit from './rejectLimit';\nimport rejectSeries from './rejectSeries';\nimport retry from './retry';\nimport retryable from './retryable';\nimport seq from './seq';\nimport series from './series';\nimport setImmediate from './setImmediate';\nimport some from './some';\nimport someLimit from './someLimit';\nimport someSeries from './someSeries';\nimport sortBy from './sortBy';\nimport timeout from './timeout';\nimport times from './times';\nimport timesLimit from './timesLimit';\nimport timesSeries from './timesSeries';\nimport transform from './transform';\nimport unmemoize from './unmemoize';\nimport until from './until';\nimport waterfall from './waterfall';\nimport whilst from './whilst';\n\nexport default {\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    apply: apply,\n    asyncify: asyncify,\n    auto: auto,\n    autoInject: autoInject,\n    cargo: cargo,\n    compose: compose,\n    concat: concat,\n    concatSeries: concatSeries,\n    constant: constant,\n    detect: detect,\n    detectLimit: detectLimit,\n    detectSeries: detectSeries,\n    dir: dir,\n    doDuring: doDuring,\n    doUntil: doUntil,\n    doWhilst: doWhilst,\n    during: during,\n    each: each,\n    eachLimit: eachLimit,\n    eachOf: eachOf,\n    eachOfLimit: eachOfLimit,\n    eachOfSeries: eachOfSeries,\n    eachSeries: eachSeries,\n    ensureAsync: ensureAsync,\n    every: every,\n    everyLimit: everyLimit,\n    everySeries: everySeries,\n    filter: filter,\n    filterLimit: filterLimit,\n    filterSeries: filterSeries,\n    forever: forever,\n    iterator: iterator,\n    log: log,\n    map: map,\n    mapLimit: mapLimit,\n    mapSeries: mapSeries,\n    mapValues: mapValues,\n    mapValuesLimit: mapValuesLimit,\n    mapValuesSeries: mapValuesSeries,\n    memoize: memoize,\n    nextTick: nextTick,\n    parallel: parallel,\n    parallelLimit: parallelLimit,\n    priorityQueue: priorityQueue,\n    queue: queue,\n    race: race,\n    reduce: reduce,\n    reduceRight: reduceRight,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    reject: reject,\n    rejectLimit: rejectLimit,\n    rejectSeries: rejectSeries,\n    retry: retry,\n    retryable: retryable,\n    seq: seq,\n    series: series,\n    setImmediate: setImmediate,\n    some: some,\n    someLimit: someLimit,\n    someSeries: someSeries,\n    sortBy: sortBy,\n    timeout: timeout,\n    times: times,\n    timesLimit: timesLimit,\n    timesSeries: timesSeries,\n    transform: transform,\n    unmemoize: unmemoize,\n    until: until,\n    waterfall: waterfall,\n    whilst: whilst,\n\n    // aliases\n    all: every,\n    any: some,\n    forEach: each,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit,\n    forEachOf: eachOf,\n    forEachOfSeries: eachOfSeries,\n    forEachOfLimit: eachOfLimit,\n    inject: reduce,\n    foldl: reduce,\n    foldr: reduceRight,\n    select: filter,\n    selectLimit: filterLimit,\n    selectSeries: filterSeries,\n    wrapSync: asyncify\n};\n\nexport {\n    applyEach as applyEach,\n    applyEachSeries as applyEachSeries,\n    apply as apply,\n    asyncify as asyncify,\n    auto as auto,\n    autoInject as autoInject,\n    cargo as cargo,\n    compose as compose,\n    concat as concat,\n    concatSeries as concatSeries,\n    constant as constant,\n    detect as detect,\n    detectLimit as detectLimit,\n    detectSeries as detectSeries,\n    dir as dir,\n    doDuring as doDuring,\n    doUntil as doUntil,\n    doWhilst as doWhilst,\n    during as during,\n    each as each,\n    eachLimit as eachLimit,\n    eachOf as eachOf,\n    eachOfLimit as eachOfLimit,\n    eachOfSeries as eachOfSeries,\n    eachSeries as eachSeries,\n    ensureAsync as ensureAsync,\n    every as every,\n    everyLimit as everyLimit,\n    everySeries as everySeries,\n    filter as filter,\n    filterLimit as filterLimit,\n    filterSeries as filterSeries,\n    forever as forever,\n    iterator as iterator,\n    log as log,\n    map as map,\n    mapLimit as mapLimit,\n    mapSeries as mapSeries,\n    mapValues as mapValues,\n    mapValuesLimit as mapValuesLimit,\n    mapValuesSeries as mapValuesSeries,\n    memoize as memoize,\n    nextTick as nextTick,\n    parallel as parallel,\n    parallelLimit as parallelLimit,\n    priorityQueue as priorityQueue,\n    queue as queue,\n    race as race,\n    reduce as reduce,\n    reduceRight as reduceRight,\n    reflect as reflect,\n    reflectAll as reflectAll,\n    reject as reject,\n    rejectLimit as rejectLimit,\n    rejectSeries as rejectSeries,\n    retry as retry,\n    retryable as retryable,\n    seq as seq,\n    series as series,\n    setImmediate as setImmediate,\n    some as some,\n    someLimit as someLimit,\n    someSeries as someSeries,\n    sortBy as sortBy,\n    timeout as timeout,\n    times as times,\n    timesLimit as timesLimit,\n    timesSeries as timesSeries,\n    transform as transform,\n    unmemoize as unmemoize,\n    until as until,\n    waterfall as waterfall,\n    whilst as whilst,\n\n    // Aliases\n    every as all,\n    everyLimit as allLimit,\n    everySeries as allSeries,\n    some as any,\n    someLimit as anyLimit,\n    someSeries as anySeries,\n    detect as find,\n    detectLimit as findLimit,\n    detectSeries as findSeries,\n    each as forEach,\n    eachSeries as forEachSeries,\n    eachLimit as forEachLimit,\n    eachOf as forEachOf,\n    eachOfSeries as forEachOfSeries,\n    eachOfLimit as forEachOfLimit,\n    reduce as inject,\n    reduce as foldl,\n    reduceRight as foldr,\n    filter as select,\n    filterLimit as selectLimit,\n    filterSeries as selectSeries,\n    asyncify as wrapSync\n};\n"
  },
  {
    "__docId__": 51,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/iterator.js",
    "memberof": null,
    "longname": "lib/iterator.js",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "content": "/**\n * Creates an iterator function which calls the next function in the `tasks`\n * array, returning a continuation to call the next one after that. It's also\n * possible to “peek” at the next iterator with `iterator.next()`.\n *\n * This function is used internally by the `async` module, but can be useful\n * when you want to manually control the flow of functions in series.\n *\n * @name iterator\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Array} tasks - An array of functions to run.\n * @returns The next function to run in the series.\n * @example\n *\n * var iterator = async.iterator([\n *     function() { sys.p('one'); },\n *     function() { sys.p('two'); },\n *     function() { sys.p('three'); }\n * ]);\n *\n * node> var iterator2 = iterator();\n * 'one'\n * node> var iterator3 = iterator2();\n * 'two'\n * node> iterator3();\n * 'three'\n * node> var nextfn = iterator2.next();\n * node> nextfn();\n * 'three'\n */\nexport default function(tasks) {\n    function makeCallback(index) {\n        function fn() {\n            if (tasks.length) {\n                tasks[index].apply(null, arguments);\n            }\n            return fn.next();\n        }\n        fn.next = function() {\n            return (index < tasks.length - 1) ? makeCallback(index + 1) : null;\n        };\n        return fn;\n    }\n    return makeCallback(0);\n}\n"
  },
  {
    "__docId__": 52,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "iterator",
    "memberof": "lib/iterator.js",
    "longname": "lib/iterator.js~iterator",
    "access": null,
    "export": true,
    "importPath": "async/lib/iterator.js",
    "importStyle": "iterator",
    "description": "Creates an iterator function which calls the next function in the `tasks`\narray, returning a continuation to call the next one after that. It's also\npossible to “peek” at the next iterator with `iterator.next()`.\n\nThis function is used internally by the `async` module, but can be useful\nwhen you want to manually control the flow of functions in series.",
    "examples": [
      "\nvar iterator = async.iterator([\n    function() { sys.p('one'); },\n    function() { sys.p('two'); },\n    function() { sys.p('three'); }\n]);\n\nnode> var iterator2 = iterator();\n'one'\nnode> var iterator3 = iterator2();\n'two'\nnode> iterator3();\n'three'\nnode> var nextfn = iterator2.next();\nnode> nextfn();\n'three'"
    ],
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "iterator"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "The next function to run in the series."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "An array of functions to run."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "The next function to run in the series."
    },
    "generator": false
  },
  {
    "__docId__": 53,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/log.js",
    "memberof": null,
    "longname": "lib/log.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import consoleFunc from './internal/consoleFunc';\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nexport default consoleFunc('log');\n"
  },
  {
    "__docId__": 54,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/map.js",
    "memberof": null,
    "longname": "lib/map.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import mapLimit from './mapLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines)\n *\n * @name map\n * @static\n * @memberOf async\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed item. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nexport default doLimit(mapLimit, Infinity);\n"
  },
  {
    "__docId__": 55,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/mapLimit.js",
    "memberof": null,
    "longname": "lib/mapLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import doParallelLimit from './internal/doParallelLimit';\nimport map from './internal/map';\n\n/**\n * The same as `map` but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf async\n * @see async.map\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a transformed\n * item. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nexport default doParallelLimit(map);\n"
  },
  {
    "__docId__": 56,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/mapSeries.js",
    "memberof": null,
    "longname": "lib/mapSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import mapLimit from './mapLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `map` but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf async\n * @see async.map\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed item. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nexport default doLimit(mapLimit, 1);\n"
  },
  {
    "__docId__": 57,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/mapValues.js",
    "memberof": null,
    "longname": "lib/mapValues.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import mapValuesLimit from './mapValuesLimit';\nimport doLimit from './internal/doLimit';\n\n\n/**\n * A relative of `map`, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf async\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each value and key in\n * `coll`. The iteratee is passed a `callback(err, transformed)` which must be\n * called once it has completed with an error (which can be `null`) and a\n * transformed value. Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `obj`. Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, fs.stat, function(err, result) {\n *     // results is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nexport default doLimit(mapValuesLimit, Infinity);\n"
  },
  {
    "__docId__": 58,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/mapValuesLimit.js",
    "memberof": null,
    "longname": "lib/mapValuesLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachOfLimit from './eachOfLimit';\n\n/**\n * The same as `mapValues` but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf async\n * @see async.mapValues\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A function to apply to each value in `obj`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed value. Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an object of the\n * transformed values from the `obj`. Invoked with (err, result).\n */\nexport default function mapValuesLimit(obj, limit, iteratee, callback) {\n    var newObj = {};\n    eachOfLimit(obj, limit, function(val, key, next) {\n        iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n"
  },
  {
    "__docId__": 59,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "mapValuesLimit",
    "memberof": "lib/mapValuesLimit.js",
    "longname": "lib/mapValuesLimit.js~mapValuesLimit",
    "access": null,
    "export": true,
    "importPath": "async/lib/mapValuesLimit.js",
    "importStyle": "mapValuesLimit",
    "description": "The same as `mapValues` but runs a maximum of `limit` async operations at a\ntime.",
    "see": [
      "async.mapValues"
    ],
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "mapValuesLimit"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "A collection to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "limit",
        "description": "The maximum number of async operations at a time."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function to apply to each value in `obj`.\nThe iteratee is passed a `callback(err, transformed)` which must be called\nonce it has completed with an error (which can be `null`) and a\ntransformed value. Invoked with (value, key, callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called when all `iteratee`\nfunctions have finished, or an error occurs. Result is an object of the\ntransformed values from the `obj`. Invoked with (err, result)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 60,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/mapValuesSeries.js",
    "memberof": null,
    "longname": "lib/mapValuesSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import mapValuesLimit from './mapValuesLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `mapValues` but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf async\n * @see async.mapValues\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each value in `obj`.\n * The iteratee is passed a `callback(err, transformed)` which must be called\n * once it has completed with an error (which can be `null`) and a\n * transformed value. Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an object of the\n * transformed values from the `obj`. Invoked with (err, result).\n */\nexport default doLimit(mapValuesLimit, 1);\n"
  },
  {
    "__docId__": 61,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/memoize.js",
    "memberof": null,
    "longname": "lib/memoize.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import identity from 'lodash/identity';\nimport rest from 'lodash/rest';\n\nimport setImmediate from './internal/setImmediate';\nimport initialParams from './internal/initialParams';\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an `async` function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} fn - The function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {Function} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nexport default function memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate(function() {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            fn.apply(null, args.concat([rest(function(args) {\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            })]));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n"
  },
  {
    "__docId__": 62,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "has",
    "memberof": "lib/memoize.js",
    "longname": "lib/memoize.js~has",
    "access": null,
    "export": false,
    "importPath": "async/lib/memoize.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 63,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "memoize",
    "memberof": "lib/memoize.js",
    "longname": "lib/memoize.js~memoize",
    "access": null,
    "export": true,
    "importPath": "async/lib/memoize.js",
    "importStyle": "memoize",
    "description": "Caches the results of an `async` function. When creating a hash to store\nfunction results against, the callback is omitted from the hash and an\noptional hash function can be used.\n\nIf no hash function is specified, the first argument is used as a hash key,\nwhich may work reasonably if it is a string or a data type that converts to a\ndistinct string. Note that objects and arrays will not behave reasonably.\nNeither will cases where the other arguments are significant. In such cases,\nspecify your own hash function.\n\nThe cache of results is exposed as the `memo` property of the function\nreturned by `memoize`.",
    "examples": [
      "\nvar slow_fn = function(name, callback) {\n    // do something\n    callback(null, result);\n};\nvar fn = async.memoize(slow_fn);\n\n// fn can now be used as if it were slow_fn\nfn('some name', function() {\n    // callback\n});"
    ],
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "memoize"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} a memoized version of `fn`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "The function to proxy and cache results from."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "hasher",
        "description": "An optional function for generating a custom hash\nfor storing results. It has all the arguments applied to it apart from the\ncallback, and must be synchronous."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "a memoized version of `fn`"
    },
    "generator": false
  },
  {
    "__docId__": 64,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/nextTick.js",
    "memberof": null,
    "longname": "lib/nextTick.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "'use strict';\n\nimport { hasNextTick, hasSetImmediate, fallback, wrap }  from './internal/setImmediate';\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `setImmediate`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf async\n * @alias setImmediate\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer;\n\nif (hasNextTick) {\n    _defer = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else {\n    _defer = fallback;\n}\n\nexport default wrap(_defer);\n"
  },
  {
    "__docId__": 65,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/parallel.js",
    "memberof": null,
    "longname": "lib/parallel.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import parallelLimit from './parallelLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Array|Object} tasks - A collection containing functions to run.\n * Each function is passed a `callback(err, result)` which it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nexport default doLimit(parallelLimit, Infinity);\n"
  },
  {
    "__docId__": 66,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/parallelLimit.js",
    "memberof": null,
    "longname": "lib/parallelLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachOfLimit from './internal/eachOfLimit';\nimport parallel from './internal/parallel';\n\n/**\n * The same as `parallel` but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallel\n * @static\n * @memberOf async\n * @see async.parallel\n * @category Control Flow\n * @param {Array|Collection} tasks - A collection containing functions to run.\n * Each function is passed a `callback(err, result)` which it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nexport default function parallelLimit(tasks, limit, callback) {\n    parallel(eachOfLimit(limit), tasks, callback);\n}\n"
  },
  {
    "__docId__": 67,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parallelLimit",
    "memberof": "lib/parallelLimit.js",
    "longname": "lib/parallelLimit.js~parallelLimit",
    "access": null,
    "export": true,
    "importPath": "async/lib/parallelLimit.js",
    "importStyle": "parallelLimit",
    "description": "The same as `parallel` but runs a maximum of `limit` async operations at a\ntime.",
    "see": [
      "async.parallel"
    ],
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "parallel"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Collection"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "A collection containing functions to run.\nEach function is passed a `callback(err, result)` which it must call on\ncompletion with an error `err` (which can be `null`) and an optional `result`\nvalue."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "limit",
        "description": "The maximum number of async operations at a time."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "An optional callback to run once all the\nfunctions have completed successfully. This function gets a results array\n(or object) containing all the result arguments passed to the task callbacks.\nInvoked with (err, results)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 68,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/priorityQueue.js",
    "memberof": null,
    "longname": "lib/priorityQueue.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import arrayEach from 'lodash/_arrayEach';\nimport isArray from 'lodash/isArray';\nimport noop from 'lodash/noop';\n\nimport setImmediate from './setImmediate';\n\nimport queue from './queue';\n\n/**\n * The same as {@link async.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf async\n * @see async.queue\n * @category Control Flow\n * @param {Function} worker - An asynchronous function for processing a queued\n * task, which must call its `callback(err)` argument when finished, with an\n * optional `error` as an argument.  If you want to handle errors from an\n * individual task, pass a callback to `q.push()`. Invoked with\n * (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {queue} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nexport default function(worker, concurrency) {\n    function _compareTasks(a, b) {\n        return a.priority - b.priority;\n    }\n\n    function _binarySearch(sequence, item, compare) {\n        var beg = -1,\n            end = sequence.length - 1;\n        while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n                beg = mid;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return beg;\n    }\n\n    function _insert(q, data, priority, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate(function() {\n                q.drain();\n            });\n        }\n        arrayEach(data, function(task) {\n            var item = {\n                data: task,\n                priority: priority,\n                callback: typeof callback === 'function' ? callback : noop\n            };\n\n            q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n            setImmediate(q.process);\n        });\n    }\n\n    // Start with a normal queue\n    var q = queue(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority, callback) {\n        _insert(q, data, priority, callback);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n}\n"
  },
  {
    "__docId__": 69,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "priorityQueue",
    "memberof": "lib/priorityQueue.js",
    "longname": "lib/priorityQueue.js~priorityQueue",
    "access": null,
    "export": true,
    "importPath": "async/lib/priorityQueue.js",
    "importStyle": "priorityQueue",
    "description": "The same as {@link async.queue} only tasks are assigned a priority and\ncompleted in ascending priority order.",
    "see": [
      "async.queue"
    ],
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "priorityQueue"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "{queue} A priorityQueue object to manage the tasks. There are two\ndifferences between `queue` and `priorityQueue` objects:\n* `push(task, priority, [callback])` - `priority` should be a number. If an\n  array of `tasks` is given, all tasks will be assigned the same priority.\n* The `unshift` method was removed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "worker",
        "description": "An asynchronous function for processing a queued\ntask, which must call its `callback(err)` argument when finished, with an\noptional `error` as an argument.  If you want to handle errors from an\nindividual task, pass a callback to `q.push()`. Invoked with\n(task, callback)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "concurrency",
        "description": "An `integer` for determining how many `worker`\nfunctions should be run in parallel.  If omitted, the concurrency defaults to\n`1`.  If the concurrency is `0`, an error is thrown."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "queue"
      ],
      "spread": false,
      "description": "A priorityQueue object to manage the tasks. There are two\ndifferences between `queue` and `priorityQueue` objects:\n* `push(task, priority, [callback])` - `priority` should be a number. If an\n  array of `tasks` is given, all tasks will be assigned the same priority.\n* The `unshift` method was removed."
    },
    "generator": false
  },
  {
    "__docId__": 70,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/queue.js",
    "memberof": null,
    "longname": "lib/queue.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import queue from './internal/queue';\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {Function} started - a function returning whether or not any\n * items have been pushed and processed by the queue. Invoke with `queue.started()`.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.length()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Function} worker - An asynchronous function for processing a queued\n * task, which must call its `callback(err)` argument when finished, with an\n * optional `error` as an argument.  If you want to handle errors from an\n * individual task, pass a callback to `q.push()`. Invoked with\n * (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nexport default function (worker, concurrency) {\n    return queue(function (items, cb) {\n        worker(items[0], cb);\n    }, concurrency, 1);\n}\n"
  },
  {
    "__docId__": 71,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "QueueObject",
    "memberof": "lib/queue.js",
    "longname": "lib/queue.js~QueueObject",
    "access": null,
    "description": "A queue of tasks for the worker function to complete.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": "a function returning the number of items\nwaiting to be processed. Invoke with `queue.length()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "started",
        "description": "a function returning whether or not any\nitems have been pushed and processed by the queue. Invoke with `queue.started()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "running",
        "description": "a function returning the number of items\ncurrently being processed. Invoke with `queue.running()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "workersList",
        "description": "a function returning the array of items\ncurrently being processed. Invoke with `queue.workersList()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "idle",
        "description": "a function returning false if there are items\nwaiting or being processed, or true if not. Invoke with `queue.idle()`."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "concurrency",
        "description": "an integer for determining how many `worker`\nfunctions should be run in parallel. This property can be changed after a\n`queue` is created to alter the concurrency on-the-fly."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "push",
        "description": "add a new task to the `queue`. Calls `callback`\nonce the `worker` has finished processing the task. Instead of a single task,\na `tasks` array can be submitted. The respective callback is used for every\ntask in the list. Invoke with `queue.push(task, [callback])`,"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "unshift",
        "description": "add a new task to the front of the `queue`.\nInvoke with `queue.unshift(task, [callback])`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "saturated",
        "description": "a callback that is called when the number of\nrunning workers hits the `concurrency` limit, and further tasks will be\nqueued."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "unsaturated",
        "description": "a callback that is called when the number\nof running workers is less than the `concurrency` & `buffer` limits, and\nfurther tasks will not be queued."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "buffer",
        "description": "A minimum threshold buffer in order to say that\nthe `queue` is `unsaturated`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "empty",
        "description": "a callback that is called when the last item\nfrom the `queue` is given to a `worker`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "drain",
        "description": "a callback that is called when the last item\nfrom the `queue` has returned from the `worker`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": "a callback that is called when a task errors.\nHas the signature `function(error, task)`."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "paused",
        "description": "a boolean for determining whether the queue is\nin a paused state."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "pause",
        "description": "a function that pauses the processing of tasks\nuntil `resume()` is called. Invoke with `queue.pause()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "resume",
        "description": "a function that resumes the processing of\nqueued tasks when the queue is paused. Invoke with `queue.length()`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "kill",
        "description": "a function that removes the `drain` callback and\nempties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "QueueObject"
    }
  },
  {
    "__docId__": 72,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "queue",
    "memberof": "lib/queue.js",
    "longname": "lib/queue.js~queue",
    "access": null,
    "export": true,
    "importPath": "async/lib/queue.js",
    "importStyle": "queue",
    "description": "Creates a `queue` object with the specified `concurrency`. Tasks added to the\n`queue` are processed in parallel (up to the `concurrency` limit). If all\n`worker`s are in progress, the task is queued until one becomes available.\nOnce a `worker` completes a `task`, that `task`'s callback is called.",
    "examples": [
      "\n// create a queue object with concurrency 2\nvar q = async.queue(function(task, callback) {\n    console.log('hello ' + task.name);\n    callback();\n}, 2);\n\n// assign a callback\nq.drain = function() {\n    console.log('all items have been processed');\n};\n\n// add some items to the queue\nq.push({name: 'foo'}, function(err) {\n    console.log('finished processing foo');\n});\nq.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the queue (batch-wise)\nq.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n    console.log('finished processing item');\n});\n\n// add some items to the front of the queue\nq.unshift({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});"
    ],
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "queue"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "{QueueObject} A queue object to manage the tasks. Callbacks can\nattached as certain properties to listen for specific events during the\nlifecycle of the queue."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "worker",
        "description": "An asynchronous function for processing a queued\ntask, which must call its `callback(err)` argument when finished, with an\noptional `error` as an argument.  If you want to handle errors from an\nindividual task, pass a callback to `q.push()`. Invoked with\n(task, callback)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "concurrency",
        "description": "An `integer` for determining how many\n`worker` functions should be run in parallel.  If omitted, the concurrency\ndefaults to `1`.  If the concurrency is `0`, an error is thrown."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QueueObject"
      ],
      "spread": false,
      "description": "A queue object to manage the tasks. Callbacks can\nattached as certain properties to listen for specific events during the\nlifecycle of the queue."
    },
    "generator": false
  },
  {
    "__docId__": 73,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/race.js",
    "memberof": null,
    "longname": "lib/race.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import isArray from 'lodash/isArray';\nimport each from 'lodash/each';\nimport noop from 'lodash/noop';\nimport once from './internal/once';\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any the `tasks` completed or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Array} tasks - An array containing functions to run. Each function\n * is passed a `callback(err, result)` which it must call on completion with an\n * error `err` (which can be `null`) and an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nexport default function race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    each(tasks, function (task) {\n        task(callback);\n    });\n}\n"
  },
  {
    "__docId__": 74,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "race",
    "memberof": "lib/race.js",
    "longname": "lib/race.js~race",
    "access": null,
    "export": true,
    "importPath": "async/lib/race.js",
    "importStyle": "race",
    "description": "Runs the `tasks` array of functions in parallel, without waiting until the\nprevious function has completed. Once any the `tasks` completed or pass an\nerror to its callback, the main `callback` is immediately called. It's\nequivalent to `Promise.race()`.",
    "examples": [
      "\nasync.race([\n    function(callback) {\n        setTimeout(function() {\n            callback(null, 'one');\n        }, 200);\n    },\n    function(callback) {\n        setTimeout(function() {\n            callback(null, 'two');\n        }, 100);\n    }\n],\n// main callback\nfunction(err, result) {\n    // the result will be equal to 'two' as it finishes earlier\n});"
    ],
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "race"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "undefined"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "An array containing functions to run. Each function\nis passed a `callback(err, result)` which it must call on completion with an\nerror `err` (which can be `null`) and an optional `result` value."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "A callback to run once any of the functions have\ncompleted. This function gets an error or result from the first function that\ncompleted. Invoked with (err, result)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "undefined"
    },
    "generator": false
  },
  {
    "__docId__": 75,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reduce.js",
    "memberof": null,
    "longname": "lib/reduce.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import eachOfSeries from './eachOfSeries';\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf async\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {Function} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction. The `iteratee` is passed a\n * `callback(err, reduction)` which accepts an optional error as its first\n * argument, and the state of the reduction as the second. If an error is\n * passed to the callback, the reduction is stopped and the main `callback` is\n * immediately called with the error. Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nexport default function reduce(coll, memo, iteratee, callback) {\n    eachOfSeries(coll, function(x, i, callback) {\n        iteratee(memo, x, function(err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function(err) {\n        callback(err, memo);\n    });\n}\n"
  },
  {
    "__docId__": 76,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "reduce",
    "memberof": "lib/reduce.js",
    "longname": "lib/reduce.js~reduce",
    "access": null,
    "export": true,
    "importPath": "async/lib/reduce.js",
    "importStyle": "reduce",
    "description": "Reduces `coll` into a single value using an async `iteratee` to return each\nsuccessive step. `memo` is the initial state of the reduction. This function\nonly operates in series.\n\nFor performance reasons, it may make sense to split a call to this function\ninto a parallel map, and then use the normal `Array.prototype.reduce` on the\nresults. This function is for situations where each step in the reduction\nneeds to be async; if you can get the data before reducing it, then it's\nprobably a good idea to do so.",
    "examples": [
      "\nasync.reduce([1,2,3], 0, function(memo, item, callback) {\n    // pointless async:\n    process.nextTick(function() {\n        callback(null, memo + item)\n    });\n}, function(err, result) {\n    // result is now equal to the last value of memo, which is 6\n});"
    ],
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "reduce"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@alias",
        "tagValue": "inject"
      },
      {
        "tagName": "@alias",
        "tagValue": "foldl"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "coll",
        "description": "A collection to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "memo",
        "description": "The initial state of the reduction."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function applied to each item in the\narray to produce the next step in the reduction. The `iteratee` is passed a\n`callback(err, reduction)` which accepts an optional error as its first\nargument, and the state of the reduction as the second. If an error is\npassed to the callback, the reduction is stopped and the main `callback` is\nimmediately called with the error. Invoked with (memo, item, callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after all the\n`iteratee` functions have finished. Result is the reduced value. Invoked with\n(err, result)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 77,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reduceRight.js",
    "memberof": null,
    "longname": "lib/reduceRight.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import reduce from './reduce';\n\nvar slice = Array.prototype.slice;\n\n/**\n * Same as `reduce`, only operates on `coll` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf async\n * @see async.reduce\n * @alias foldr\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {Function} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction. The `iteratee` is passed a\n * `callback(err, reduction)` which accepts an optional error as its first\n * argument, and the state of the reduction as the second. If an error is\n * passed to the callback, the reduction is stopped and the main `callback` is\n * immediately called with the error. Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nexport default function reduceRight (coll, memo, iteratee, callback) {\n    var reversed = slice.call(coll).reverse();\n    reduce(reversed, memo, iteratee, callback);\n}\n"
  },
  {
    "__docId__": 78,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "slice",
    "memberof": "lib/reduceRight.js",
    "longname": "lib/reduceRight.js~slice",
    "access": null,
    "export": false,
    "importPath": "async/lib/reduceRight.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "reduceRight",
    "memberof": "lib/reduceRight.js",
    "longname": "lib/reduceRight.js~reduceRight",
    "access": null,
    "export": true,
    "importPath": "async/lib/reduceRight.js",
    "importStyle": "reduceRight",
    "description": "Same as `reduce`, only operates on `coll` in reverse order.",
    "see": [
      "async.reduce"
    ],
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "reduceRight"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@alias",
        "tagValue": "foldr"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "coll",
        "description": "A collection to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "memo",
        "description": "The initial state of the reduction."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function applied to each item in the\narray to produce the next step in the reduction. The `iteratee` is passed a\n`callback(err, reduction)` which accepts an optional error as its first\nargument, and the state of the reduction as the second. If an error is\npassed to the callback, the reduction is stopped and the main `callback` is\nimmediately called with the error. Invoked with (memo, item, callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after all the\n`iteratee` functions have finished. Result is the reduced value. Invoked with\n(err, result)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 80,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reflect.js",
    "memberof": null,
    "longname": "lib/reflect.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import initialParams from './internal/initialParams';\nimport rest from 'lodash/rest';\n\n/**\n * Wraps the function in another function that always returns data even when it\n * errors.\n *\n * The object returned has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} fn - The function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nexport default function reflect(fn) {\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(rest(function callback(err, cbArgs) {\n            if (err) {\n                reflectCallback(null, {\n                    error: err\n                });\n            } else {\n                var value = null;\n                if (cbArgs.length === 1) {\n                    value = cbArgs[0];\n                } else if (cbArgs.length > 1) {\n                    value = cbArgs;\n                }\n                reflectCallback(null, {\n                    value: value\n                });\n            }\n        }));\n\n        return fn.apply(this, args);\n    });\n}\n"
  },
  {
    "__docId__": 81,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "reflect",
    "memberof": "lib/reflect.js",
    "longname": "lib/reflect.js~reflect",
    "access": null,
    "export": true,
    "importPath": "async/lib/reflect.js",
    "importStyle": "reflect",
    "description": "Wraps the function in another function that always returns data even when it\nerrors.\n\nThe object returned has either the property `error` or `value`.",
    "examples": [
      "\nasync.parallel([\n    async.reflect(function(callback) {\n        // do some stuff ...\n        callback(null, 'one');\n    }),\n    async.reflect(function(callback) {\n        // do some more stuff but error ...\n        callback('bad stuff happened');\n    }),\n    async.reflect(function(callback) {\n        // do some more stuff ...\n        callback(null, 'two');\n    })\n],\n// optional callback\nfunction(err, results) {\n    // values\n    // results[0].value = 'one'\n    // results[1].error = 'bad stuff happened'\n    // results[2].value = 'two'\n});"
    ],
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "reflect"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} - A function that always passes null to it's callback as\nthe error. The second argument to the callback will be an `object` with\neither an `error` or a `value` property."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "The function you want to wrap"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "A function that always passes null to it's callback as\nthe error. The second argument to the callback will be an `object` with\neither an `error` or a `value` property."
    },
    "generator": false
  },
  {
    "__docId__": 82,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reflectAll.js",
    "memberof": null,
    "longname": "lib/reflectAll.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import reflect from './reflect';\n\n/**\n * A helper function that wraps an array of functions with reflect.\n *\n * @name reflectAll\n * @static\n * @memberOf async\n * @see async.reflect\n * @category Util\n * @param {Array} tasks - The array of functions to wrap in `async.reflect`.\n * @returns {Array} Returns an array of functions, each function wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n */\nexport default function reflectAll(tasks) {\n    return tasks.map(reflect);\n}\n"
  },
  {
    "__docId__": 83,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "reflectAll",
    "memberof": "lib/reflectAll.js",
    "longname": "lib/reflectAll.js~reflectAll",
    "access": null,
    "export": true,
    "importPath": "async/lib/reflectAll.js",
    "importStyle": "reflectAll",
    "description": "A helper function that wraps an array of functions with reflect.",
    "examples": [
      "\nlet tasks = [\n    function(callback) {\n        setTimeout(function() {\n            callback(null, 'one');\n        }, 200);\n    },\n    function(callback) {\n        // do some more stuff but error ...\n        callback(new Error('bad stuff happened'));\n    },\n    function(callback) {\n        setTimeout(function() {\n            callback(null, 'two');\n        }, 100);\n    }\n];\n\nasync.parallel(async.reflectAll(tasks),\n// optional callback\nfunction(err, results) {\n    // values\n    // results[0].value = 'one'\n    // results[1].error = Error('bad stuff happened')\n    // results[2].value = 'two'\n});"
    ],
    "see": [
      "async.reflect"
    ],
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "reflectAll"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Array} Returns an array of functions, each function wrapped in\n`async.reflect`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "The array of functions to wrap in `async.reflect`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "Returns an array of functions, each function wrapped in\n`async.reflect`"
    },
    "generator": false
  },
  {
    "__docId__": 84,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reject.js",
    "memberof": null,
    "longname": "lib/reject.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import rejectLimit from './rejectLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The opposite of `filter`. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf async\n * @see async.filter\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nexport default doLimit(rejectLimit, Infinity);\n"
  },
  {
    "__docId__": 85,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/rejectLimit.js",
    "memberof": null,
    "longname": "lib/rejectLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import reject from './internal/reject';\nimport doParallelLimit from './internal/doParallelLimit';\n\n/**\n * The same as `reject` but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf async\n * @see async.reject\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nexport default doParallelLimit(reject);\n"
  },
  {
    "__docId__": 86,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/rejectSeries.js",
    "memberof": null,
    "longname": "lib/rejectSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import rejectLimit from './rejectLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `reject` but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf async\n * @see async.reject\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nexport default doLimit(rejectLimit, 1);\n"
  },
  {
    "__docId__": 87,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/retry.js",
    "memberof": null,
    "longname": "lib/retry.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import series from './series';\nimport noop from 'lodash/noop';\nimport constant from 'lodash/constant';\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {Function} task - A function which receives two arguments: (1) a\n * `callback(err, result)` which must be called when finished, passing `err`\n * (which can be `null`) and the `result` of the function's execution, and (2)\n * a `results` object, containing the results of the previously executed\n * functions (if nested inside another control flow). Invoked with\n * (callback, results).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retry(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n */\nexport default function retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant(+t.interval || DEFAULT_INTERVAL);\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var attempts = [];\n    for (var i = 1; i < options.times + 1; i++) {\n        var isFinalAttempt = (i == options.times);\n        attempts.push(retryAttempt(isFinalAttempt));\n        var interval = options.intervalFunc(i);\n        if (!isFinalAttempt && interval > 0) {\n            attempts.push(retryInterval(interval));\n        }\n    }\n\n    series(attempts, function(done, data) {\n        data = data[data.length - 1];\n        callback(data.err, data.result);\n    });\n\n\n    function retryAttempt(isFinalAttempt) {\n        return function(seriesCallback) {\n            task(function(err, result) {\n                seriesCallback(!err || isFinalAttempt, {\n                    err: err,\n                    result: result\n                });\n            });\n        };\n    }\n\n    function retryInterval(interval) {\n        return function(seriesCallback) {\n            setTimeout(function() {\n                seriesCallback(null);\n            }, interval);\n        };\n    }\n}\n"
  },
  {
    "__docId__": 88,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "retry",
    "memberof": "lib/retry.js",
    "longname": "lib/retry.js~retry",
    "access": null,
    "export": true,
    "importPath": "async/lib/retry.js",
    "importStyle": "retry",
    "description": "Attempts to get a successful response from `task` no more than `times` times\nbefore returning an error. If the task is successful, the `callback` will be\npassed the result of the successful task. If all attempts fail, the callback\nwill be passed the error and result (if any) of the final attempt.",
    "examples": [
      "\n// The `retry` function can be used as a stand-alone control flow by passing\n// a callback, as shown below:\n\n// try calling apiMethod 3 times\nasync.retry(3, apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// try calling apiMethod 3 times, waiting 200 ms between each retry\nasync.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// try calling apiMethod 10 times with exponential backoff\n// (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\nasync.retry({\n  times: 10,\n  interval: function(retryCount) {\n    return 50 * Math.pow(2, retryCount);\n  }\n}, apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// try calling apiMethod the default 5 times no delay between each retry\nasync.retry(apiMethod, function(err, result) {\n    // do something with the result\n});\n\n// It can also be embedded within other control flow functions to retry\n// individual methods that are not as reliable, like this:\nasync.auto({\n    users: api.getUsers.bind(api),\n    payments: async.retry(3, api.getPayments.bind(api))\n}, function(err, results) {\n    // do something with the results\n});"
    ],
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "retry"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "opts",
        "description": "= {times: 5, interval: 0}| 5] - Can be either an\nobject with `times` and `interval` or a number.\n* `times` - The number of attempts to make before giving up.  The default\n  is `5`.\n* `interval` - The time to wait between retries, in milliseconds.  The\n  default is `0`. The interval may also be specified as a function of the\n  retry count (see example).\n* If `opts` is a number, the number specifies the number of times to retry,\n  with the default interval of `0`."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "task",
        "description": "A function which receives two arguments: (1) a\n`callback(err, result)` which must be called when finished, passing `err`\n(which can be `null`) and the `result` of the function's execution, and (2)\na `results` object, containing the results of the previously executed\nfunctions (if nested inside another control flow). Invoked with\n(callback, results)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "An optional callback which is called when the\ntask has succeeded, or after the final failed attempt. It receives the `err`\nand `result` arguments of the last attempt at completing the `task`. Invoked\nwith (err, results)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 89,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/retryable.js",
    "memberof": null,
    "longname": "lib/retryable.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import retry from './retry';\nimport initialParams from './internal/initialParams';\n\n/**\n * A close relative of `retry`.  This method wraps a task and makes it\n * retryable, rather than immediately calling it with retries.\n *\n * @name retryable\n * @static\n * @memberOf async\n * @see async.retry\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {Function} task - the asynchronous function to wrap\n * @returns {Functions} The wrapped function, which when invoked, will retry on\n * an error, based on the parameters specified in `opts`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nexport default function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            task.apply(null, args.concat([cb]));\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n    });\n}\n"
  },
  {
    "__docId__": 90,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "retryable",
    "memberof": "lib/retryable.js",
    "longname": "lib/retryable.js~retryable",
    "access": null,
    "export": true,
    "importPath": "async/lib/retryable.js",
    "importStyle": "retryable",
    "description": "A close relative of `retry`.  This method wraps a task and makes it\nretryable, rather than immediately calling it with retries.",
    "examples": [
      "\nasync.auto({\n    dep1: async.retryable(3, getFromFlakyService),\n    process: [\"dep1\", async.retryable(3, function (results, cb) {\n        maybeProcessData(results.dep1, cb);\n    })]\n}, callback);"
    ],
    "see": [
      "async.retry"
    ],
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "retryable"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Functions} The wrapped function, which when invoked, will retry on\nan error, based on the parameters specified in `opts`."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "opts",
        "description": "= {times: 5, interval: 0}| 5] - optional\noptions, exactly the same as from `retry`"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "task",
        "description": "the asynchronous function to wrap"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Functions"
      ],
      "spread": false,
      "description": "The wrapped function, which when invoked, will retry on\nan error, based on the parameters specified in `opts`."
    },
    "generator": false
  },
  {
    "__docId__": 91,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/seq.js",
    "memberof": null,
    "longname": "lib/seq.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import noop from 'lodash/noop';\nimport rest from 'lodash/rest';\nimport reduce from './reduce';\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * {@link async.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf async\n * @see async.compose\n * @category Control Flow\n * @param {...Function} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nexport default rest(function seq(functions) {\n    return rest(function(args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(functions, args, function(newargs, fn, cb) {\n            fn.apply(that, newargs.concat([rest(function(err, nextargs) {\n                cb(err, nextargs);\n            })]));\n        },\n        function(err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    });\n})\n"
  },
  {
    "__docId__": 92,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/series.js",
    "memberof": null,
    "longname": "lib/series.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import parallel from './internal/parallel';\nimport eachOfSeries from './eachOfSeries';\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Array|Object} tasks - A collection containing functions to run, each\n * function is passed a `callback(err, result)` it must call on completion with\n * an error `err` (which can be `null`) and an optional `result` value.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nexport default function series(tasks, callback) {\n    parallel(eachOfSeries, tasks, callback);\n}\n"
  },
  {
    "__docId__": 93,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "series",
    "memberof": "lib/series.js",
    "longname": "lib/series.js~series",
    "access": null,
    "export": true,
    "importPath": "async/lib/series.js",
    "importStyle": "series",
    "description": "Run the functions in the `tasks` collection in series, each one running once\nthe previous function has completed. If any functions in the series pass an\nerror to its callback, no more functions are run, and `callback` is\nimmediately called with the value of the error. Otherwise, `callback`\nreceives an array of results when `tasks` have completed.\n\nIt is also possible to use an object instead of an array. Each property will\nbe run as a function, and the results will be passed to the final `callback`\nas an object instead of an array. This can be a more readable way of handling\n results from {@link async.series}.\n\n**Note** that while many implementations preserve the order of object\nproperties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\nexplicitly states that\n\n> The mechanics and order of enumerating the properties is not specified.\n\nSo if you rely on the order in which your series of functions are executed,\nand want this to work on all platforms, consider using an array.",
    "examples": [
      "async.series([\n    function(callback) {\n        // do some stuff ...\n        callback(null, 'one');\n    },\n    function(callback) {\n        // do some more stuff ...\n        callback(null, 'two');\n    }\n],\n// optional callback\nfunction(err, results) {\n    // results is now equal to ['one', 'two']\n});\n\nasync.series({\n    one: function(callback) {\n        setTimeout(function() {\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function() {\n            callback(null, 2);\n        }, 100);\n    }\n}, function(err, results) {\n    // results is now equal to: {one: 1, two: 2}\n});"
    ],
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "series"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "A collection containing functions to run, each\nfunction is passed a `callback(err, result)` it must call on completion with\nan error `err` (which can be `null`) and an optional `result` value."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "An optional callback to run once all the\nfunctions have completed. This function gets a results array (or object)\ncontaining all the result arguments passed to the `task` callbacks. Invoked\nwith (err, result)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 94,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/setImmediate.js",
    "memberof": null,
    "longname": "lib/setImmediate.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import setImmediate from './internal/setImmediate';\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `setImmediate`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name setImmediate\n * @static\n * @memberOf async\n * @alias nextTick\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nexport default setImmediate;\n"
  },
  {
    "__docId__": 95,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/some.js",
    "memberof": null,
    "longname": "lib/some.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import someLimit from './someLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf async\n * @alias any\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the array\n * in parallel. The iteratee is passed a `callback(err, truthValue)` which must\n * be called with a boolean argument once it has completed. Invoked with\n * (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nexport default doLimit(someLimit, Infinity);\n"
  },
  {
    "__docId__": 96,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/someLimit.js",
    "memberof": null,
    "longname": "lib/someLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import createTester from './internal/createTester';\nimport eachOfLimit from './eachOfLimit';\nimport identity from 'lodash/identity';\n\n/**\n * The same as `some` but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf async\n * @see async.some\n * @alias anyLimit\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in the array\n * in parallel. The iteratee is passed a `callback(err, truthValue)` which must\n * be called with a boolean argument once it has completed. Invoked with\n * (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nexport default createTester(eachOfLimit, Boolean, identity);\n"
  },
  {
    "__docId__": 97,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/someSeries.js",
    "memberof": null,
    "longname": "lib/someSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import someLimit from './someLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as `some` but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf async\n * @see async.some\n * @alias anySeries\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in the array\n * in parallel. The iteratee is passed a `callback(err, truthValue)` which must\n * be called with a boolean argument once it has completed. Invoked with\n * (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nexport default doLimit(someLimit, 1);\n"
  },
  {
    "__docId__": 98,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/sortBy.js",
    "memberof": null,
    "longname": "lib/sortBy.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import arrayMap from 'lodash/_arrayMap';\nimport property from 'lodash/_baseProperty';\n\nimport map from './map';\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf async\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A function to apply to each item in `coll`.\n * The iteratee is passed a `callback(err, sortValue)` which must be called once\n * it has completed with an error (which can be `null`) and a value to use as\n * the sort criteria. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nexport default function sortBy (coll, iteratee, callback) {\n    map(coll, function (x, callback) {\n        iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, {value: x, criteria: criteria});\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), property('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n"
  },
  {
    "__docId__": 99,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "sortBy",
    "memberof": "lib/sortBy.js",
    "longname": "lib/sortBy.js~sortBy",
    "access": null,
    "export": true,
    "importPath": "async/lib/sortBy.js",
    "importStyle": "sortBy",
    "description": "Sorts a list by the results of running each `coll` value through an async\n`iteratee`.",
    "examples": [
      "\nasync.sortBy(['file1','file2','file3'], function(file, callback) {\n    fs.stat(file, function(err, stats) {\n        callback(err, stats.mtime);\n    });\n}, function(err, results) {\n    // results is now the original array of files sorted by\n    // modified date\n});\n\n// By modifying the callback parameter the\n// sorting order can be influenced:\n\n// ascending order\nasync.sortBy([1,9,3,5], function(x, callback) {\n    callback(null, x);\n}, function(err,result) {\n    // result callback\n});\n\n// descending order\nasync.sortBy([1,9,3,5], function(x, callback) {\n    callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n}, function(err,result) {\n    // result callback\n});"
    ],
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "sortBy"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "coll",
        "description": "A collection to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function to apply to each item in `coll`.\nThe iteratee is passed a `callback(err, sortValue)` which must be called once\nit has completed with an error (which can be `null`) and a value to use as\nthe sort criteria. Invoked with (item, callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after all the\n`iteratee` functions have finished, or an error occurs. Results is the items\nfrom the original `coll` sorted by the values returned by the `iteratee`\ncalls. Invoked with (err, results)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 100,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/timeout.js",
    "memberof": null,
    "longname": "lib/timeout.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import initialParams from './internal/initialParams';\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf async\n * @category Util\n * @param {Function} asyncFn - The asynchronous function you want to set the\n * time limit.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {Function} Returns a wrapped function that can be used with any of\n * the control flow functions.\n * @example\n *\n * async.timeout(function(callback) {\n *     doAsyncTask(callback);\n * }, 1000);\n */\nexport default function timeout(asyncFn, milliseconds, info) {\n    var originalCallback, timer;\n    var timedOut = false;\n\n    function injectedCallback() {\n        if (!timedOut) {\n            originalCallback.apply(null, arguments);\n            clearTimeout(timer);\n        }\n    }\n\n    function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error  = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n            error.info = info;\n        }\n        timedOut = true;\n        originalCallback(error);\n    }\n\n    return initialParams(function (args, origCallback) {\n        originalCallback = origCallback;\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        asyncFn.apply(null, args.concat(injectedCallback));\n    });\n}\n"
  },
  {
    "__docId__": 101,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "timeout",
    "memberof": "lib/timeout.js",
    "longname": "lib/timeout.js~timeout",
    "access": null,
    "export": true,
    "importPath": "async/lib/timeout.js",
    "importStyle": "timeout",
    "description": "Sets a time limit on an asynchronous function. If the function does not call\nits callback within the specified milliseconds, it will be called with a\ntimeout error. The code property for the error object will be `'ETIMEDOUT'`.",
    "examples": [
      "\nasync.timeout(function(callback) {\n    doAsyncTask(callback);\n}, 1000);"
    ],
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "timeout"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} Returns a wrapped function that can be used with any of\nthe control flow functions."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "asyncFn",
        "description": "The asynchronous function you want to set the\ntime limit."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "milliseconds",
        "description": "The specified time limit."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "info",
        "description": "Any variable you want attached (`string`, `object`, etc)\nto timeout Error for more information.."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "Returns a wrapped function that can be used with any of\nthe control flow functions."
    },
    "generator": false
  },
  {
    "__docId__": 102,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/times.js",
    "memberof": null,
    "longname": "lib/times.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import timesLimit from './timesLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with {@link async.map}.\n *\n * @name times\n * @static\n * @memberOf async\n * @see async.map\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {Function} iteratee - The function to call `n` times. Invoked with the\n * iteration index and a callback (n, next).\n * @param {Function} callback - see {@link async.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nexport default doLimit(timesLimit, Infinity);\n"
  },
  {
    "__docId__": 103,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/timesLimit.js",
    "memberof": null,
    "longname": "lib/timesLimit.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import mapLimit from './mapLimit';\nimport range from 'lodash/_baseRange';\n\n/**\n* The same as {@link times} but runs a maximum of `limit` async operations at a\n* time.\n *\n * @name timesLimit\n * @static\n * @memberOf async\n * @see async.times\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - The function to call `n` times. Invoked with the\n * iteration index and a callback (n, next).\n * @param {Function} callback - see {@link async.map}.\n */\nexport default function timeLimit(count, limit, iteratee, callback) {\n    mapLimit(range(0, count, 1), limit, iteratee, callback);\n}\n"
  },
  {
    "__docId__": 104,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "timeLimit",
    "memberof": "lib/timesLimit.js",
    "longname": "lib/timesLimit.js~timeLimit",
    "access": null,
    "export": true,
    "importPath": "async/lib/timesLimit.js",
    "importStyle": "timeLimit",
    "description": "The same as {@link times} but runs a maximum of `limit` async operations at a\ntime.",
    "see": [
      "async.times"
    ],
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "timesLimit"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "The number of times to run the function."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "limit",
        "description": "The maximum number of async operations at a time."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "The function to call `n` times. Invoked with the\niteration index and a callback (n, next)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "see {@link async.map}."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 105,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/timesSeries.js",
    "memberof": null,
    "longname": "lib/timesSeries.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import timesLimit from './timesLimit';\nimport doLimit from './internal/doLimit';\n\n/**\n * The same as {@link async.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf async\n * @see async.times\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {Function} iteratee - The function to call `n` times. Invoked with the\n * iteration index and a callback (n, next).\n * @param {Function} callback - see {@link async.map}.\n */\nexport default doLimit(timesLimit, 1);\n"
  },
  {
    "__docId__": 106,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/transform.js",
    "memberof": null,
    "longname": "lib/transform.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import isArray from 'lodash/isArray';\n\nimport eachOf from './eachOf';\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf async\n * @category Collection\n * @param {Array|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {Function} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator. The `iteratee` is\n * passed a `callback(err)` which accepts an optional error as its first\n * argument. If an error is passed to the callback, the transform is stopped\n * and the main `callback` is immediately called with the error.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nexport default function transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length === 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n\n    eachOf(coll, function(v, k, cb) {\n        iteratee(accumulator, v, k, cb);\n    }, function(err) {\n        callback(err, accumulator);\n    });\n}\n"
  },
  {
    "__docId__": 107,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "transform",
    "memberof": "lib/transform.js",
    "longname": "lib/transform.js~transform",
    "access": null,
    "export": true,
    "importPath": "async/lib/transform.js",
    "importStyle": "transform",
    "description": "A relative of `reduce`.  Takes an Object or Array, and iterates over each\nelement in series, each step potentially mutating an `accumulator` value.\nThe type of the accumulator defaults to the type of collection passed in.",
    "examples": [
      "\nasync.transform([1,2,3], function(acc, item, index, callback) {\n    // pointless async:\n    process.nextTick(function() {\n        acc.push(item * 2)\n        callback(null)\n    });\n}, function(err, result) {\n    // result is now equal to [2, 4, 6]\n});",
      "\nasync.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n    setImmediate(function () {\n        obj[key] = val * 2;\n        callback();\n    })\n}, function (err, result) {\n    // result is equal to {a: 2, b: 4, c: 6}\n})"
    ],
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "transform"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Collection"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "coll",
        "description": "A collection to iterate over."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "accumulator",
        "description": "The initial state of the transform.  If omitted,\nit will default to an empty Object or Array, depending on the type of `coll`"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function applied to each item in the\ncollection that potentially modifies the accumulator. The `iteratee` is\npassed a `callback(err)` which accepts an optional error as its first\nargument. If an error is passed to the callback, the transform is stopped\nand the main `callback` is immediately called with the error.\nInvoked with (accumulator, item, key, callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after all the\n`iteratee` functions have finished. Result is the transformed accumulator.\nInvoked with (err, result)."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 108,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/unmemoize.js",
    "memberof": null,
    "longname": "lib/unmemoize.js",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "content": "/**\n * Undoes a {@link async.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf async\n * @see async.memoize\n * @category Util\n * @param {Function} fn - the memoized function\n * @returns {Function} a function that calls the original unmemoized function\n */\nexport default  function unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n"
  },
  {
    "__docId__": 109,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "unmemoize",
    "memberof": "lib/unmemoize.js",
    "longname": "lib/unmemoize.js~unmemoize",
    "access": null,
    "export": true,
    "importPath": "async/lib/unmemoize.js",
    "importStyle": "unmemoize",
    "description": "Undoes a {@link async.memoize}d function, reverting it to the original,\nunmemoized form. Handy for testing.",
    "see": [
      "async.memoize"
    ],
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "unmemoize"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Util"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Function} a function that calls the original unmemoized function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "the memoized function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": "a function that calls the original unmemoized function"
    },
    "generator": false
  },
  {
    "__docId__": 110,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/until.js",
    "memberof": null,
    "longname": "lib/until.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import whilst from './whilst';\n\n/**\n * Repeatedly call `fn` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `fn`'s callback.\n *\n * The inverse of {@link async.whilst}.\n *\n * @name until\n * @static\n * @memberOf async\n * @see async.whilst\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `fn`. Invoked with ().\n * @param {Function} fn - A function which is called each time `test` fails.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n */\nexport default function until(test, fn, callback) {\n    whilst(function() {\n        return !test.apply(this, arguments);\n    }, fn, callback);\n}\n"
  },
  {
    "__docId__": 111,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "until",
    "memberof": "lib/until.js",
    "longname": "lib/until.js~until",
    "access": null,
    "export": true,
    "importPath": "async/lib/until.js",
    "importStyle": "until",
    "description": "Repeatedly call `fn` until `test` returns `true`. Calls `callback` when\nstopped, or an error occurs. `callback` will be passed an error and any\narguments passed to the final `fn`'s callback.\n\nThe inverse of {@link async.whilst}.",
    "see": [
      "async.whilst"
    ],
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "until"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "synchronous truth test to perform before each\nexecution of `fn`. Invoked with ()."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "A function which is called each time `test` fails.\nThe function is passed a `callback(err)`, which must be called once it has\ncompleted with an optional `err` argument. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after the test\nfunction has passed and repeated execution of `fn` has stopped. `callback`\nwill be passed an error and any arguments passed to the final `fn`'s\ncallback. Invoked with (err, [results]);"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 112,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/waterfall.js",
    "memberof": null,
    "longname": "lib/waterfall.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import isArray from 'lodash/isArray';\nimport noop from 'lodash/noop';\nimport once from './internal/once';\nimport rest from 'lodash/rest';\n\nimport onlyOnce from './internal/onlyOnce';\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Array} tasks - An array of functions to run, each function is passed\n * a `callback(err, result1, result2, ...)` it must call on completion. The\n * first argument is an error (which can be `null`) and any further arguments\n * will be passed as arguments in order to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nexport default  function(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        if (taskIndex === tasks.length) {\n            return callback.apply(null, [null].concat(args));\n        }\n\n        var taskCallback = onlyOnce(rest(function(err, args) {\n            if (err) {\n                return callback.apply(null, [err].concat(args));\n            }\n            nextTask(args);\n        }));\n\n        args.push(taskCallback);\n\n        var task = tasks[taskIndex++];\n        task.apply(null, args);\n    }\n\n    nextTask([]);\n}\n"
  },
  {
    "__docId__": 113,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "waterfall",
    "memberof": "lib/waterfall.js",
    "longname": "lib/waterfall.js~waterfall",
    "access": null,
    "export": true,
    "importPath": "async/lib/waterfall.js",
    "importStyle": "waterfall",
    "description": "Runs the `tasks` array of functions in series, each passing their results to\nthe next in the array. However, if any of the `tasks` pass an error to their\nown callback, the next function is not executed, and the main `callback` is\nimmediately called with the error.",
    "examples": [
      "\nasync.waterfall([\n    function(callback) {\n        callback(null, 'one', 'two');\n    },\n    function(arg1, arg2, callback) {\n        // arg1 now equals 'one' and arg2 now equals 'two'\n        callback(null, 'three');\n    },\n    function(arg1, callback) {\n        // arg1 now equals 'three'\n        callback(null, 'done');\n    }\n], function (err, result) {\n    // result now equals 'done'\n});\n\n// Or, with named functions:\nasync.waterfall([\n    myFirstFunction,\n    mySecondFunction,\n    myLastFunction,\n], function (err, result) {\n    // result now equals 'done'\n});\nfunction myFirstFunction(callback) {\n    callback(null, 'one', 'two');\n}\nfunction mySecondFunction(arg1, arg2, callback) {\n    // arg1 now equals 'one' and arg2 now equals 'two'\n    callback(null, 'three');\n}\nfunction myLastFunction(arg1, callback) {\n    // arg1 now equals 'three'\n    callback(null, 'done');\n}"
    ],
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "waterfall"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "undefined"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "tasks",
        "description": "An array of functions to run, each function is passed\na `callback(err, result1, result2, ...)` it must call on completion. The\nfirst argument is an error (which can be `null`) and any further arguments\nwill be passed as arguments in order to the next task."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "An optional callback to run once all the\nfunctions have completed. This will be passed the results of the last task's\ncallback. Invoked with (err, [results])."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "undefined"
    },
    "generator": false
  },
  {
    "__docId__": 114,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/whilst.js",
    "memberof": null,
    "longname": "lib/whilst.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import noop from 'lodash/noop';\nimport rest from 'lodash/rest';\n\n/**\n * Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf async\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `fn`. Invoked with ().\n * @param {Function} iteratee - A function which is called each time `test` passes.\n * The function is passed a `callback(err)`, which must be called once it has\n * completed with an optional `err` argument. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `fn`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nexport default function whilst(test, iteratee, callback) {\n    callback = callback || noop;\n    if (!test()) return callback(null);\n    var next = rest(function(err, args) {\n        if (err) return callback(err);\n        if (test.apply(this, args)) return iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    iteratee(next);\n}\n"
  },
  {
    "__docId__": 115,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "whilst",
    "memberof": "lib/whilst.js",
    "longname": "lib/whilst.js~whilst",
    "access": null,
    "export": true,
    "importPath": "async/lib/whilst.js",
    "importStyle": "whilst",
    "description": "Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when\nstopped, or an error occurs.",
    "examples": [
      "\nvar count = 0;\nasync.whilst(\n    function() { return count < 5; },\n    function(callback) {\n        count++;\n        setTimeout(function() {\n            callback(null, count);\n        }, 1000);\n    },\n    function (err, n) {\n        // 5 seconds have passed, n = 5\n    }\n);"
    ],
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@name",
        "tagValue": "whilst"
      },
      {
        "tagName": "@static",
        "tagValue": ""
      },
      {
        "tagName": "@memberOf",
        "tagValue": "async"
      },
      {
        "tagName": "@category",
        "tagValue": "Control Flow"
      },
      {
        "tagName": "@returns",
        "tagValue": "undefined"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "test",
        "description": "synchronous truth test to perform before each\nexecution of `fn`. Invoked with ()."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "iteratee",
        "description": "A function which is called each time `test` passes.\nThe function is passed a `callback(err)`, which must be called once it has\ncompleted with an optional `err` argument. Invoked with (callback)."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "callback",
        "description": "A callback which is called after the test\nfunction has failed and repeated execution of `fn` has stopped. `callback`\nwill be passed an error and any arguments passed to the final `fn`'s\ncallback. Invoked with (err, [results]);"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "undefined"
    },
    "generator": false
  },
  {
    "__docId__": 117,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 118,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 119,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 120,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 121,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 122,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 123,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 124,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 125,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 126,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 127,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 128,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 129,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 130,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 131,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 132,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 133,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 134,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 135,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 136,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 137,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 138,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 139,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 140,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 141,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 142,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 143,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 144,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 145,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 146,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 147,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 148,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 149,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 150,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 151,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 152,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 153,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 154,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 155,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 156,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 157,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 158,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 159,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 160,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 161,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 162,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 163,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 165,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 166,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 167,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 168,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 169,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 170,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 171,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 172,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "builtinExternal": true
  }
]